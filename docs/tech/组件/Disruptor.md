# Disruptor
Disruptor它是一个开源的并发框架，能够在无锁的情况下实现网络的Queue并发操作。

## 锁的缺点

1.锁最慢，CAS次之。如果是能够优化场景，消除竞态资源。让一个线程去操作，那么效率肯定是最高的。

```
a 没有竞争=没有锁=非常快。
b 所有访问者都记录自己的序号的实现方式，允许多个生产者与多个消费者共享相同的数据结构。
c 在每个对象中都能跟踪序列号（ring buffer，claim Strategy，生产者和消费者），加上神奇的cache line padding，就意味着没有为伪共享和非预期的竞争。
```

## 缓存行的填充

1.缓存`注意不是内存`是由缓存行`cache line`组成的，通常是64字节。如果你访问一个long数组，当数组中的一个值被加载到缓存中，它会额外加载另外7个。因此你能非常快地遍历这个数组。   `链表不行，因为存储地址不连续`

2.伪共享。如果变量A、B都在一个缓存行里，且都被`volatile`修饰，一个线程要改A，改完后，所有内存和缓存的A、B都会被同步重新加载。`这是由volatile决定的，内存栅栏`。这就造成一个浪费。就因为A改了，所以只需要读B的线程都要浪费重新加载B的时间。

>操作的是两个变量，却产生了相互干扰，拖慢了执行效率

## Ring Buffer

1.消费者会申请一批可以读取的序号，然后开始消费。`ConsumerBarrier会告诉消费者，哪些可以序号对应的数据可以消费了`
>那么在多个消费者的情况下阻止重复消费呢？我猜测可以在entry上有个volatile修饰的变量，代表是否被消费。或者ConsumerBarrier如果给出了坑位，就将坑位从可消费列表里移除。

2.生产者会申请一批可以写入的序号，然后开始写入。写入过程是二阶段提交。

```
a 如果目前没有坑位可以写入，生产者自旋。ProducerBarier会监控所有消费者的消费情况。写完会通知消费者。
b 两阶段提交在多个消费者的情况下体现的很好。假设A拿到坑位12，B拿到坑位13。B先写完了，但是他不能够提交，B需要等待A提交后，才能提交。
```

3.如果消费者是有依赖关系的，那么有n个依赖关系，就有n+1个ConsumerBarrier `数据是我猜测的，ConsumerBarrier负责计算消费者可以消费的坑位`


```
假设一个依赖：C的执行需要A、B都执行完毕。
    I.那么有两个ConsumerBarrier。CB1和CB2。
    II.A和B没有依赖关系。所以CB1会告诉A和B目前可以消费的坑位
    III.CB2会根据A、B的执行情况，计算出来A、B都执行过的坑位，告诉C
    IV.ProducerBarrier 只会监控最后一个消费者，就是C
```

4.获取下一个可以写入的坑位使用的是CAS。写入数据可见的先后顺序是由线程所抢占的位置的先后顺序决定的，而不是由它的提交先后决定的。
>线程A抢到坑位4，线程B抢到坑位5.如果A不提交完毕，那么B无法提交。提交完毕，才对消费者可见。所以抢占的位置，决定了可见的顺序。



[并发框架Disruptor译文](http://ifeve.com/disruptor)

[高性能并发框架 Disruptor](https://yangbingdong.com/2018/disruptor-learning/)


