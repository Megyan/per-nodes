# 数据库-锁&索引

## 锁的类型
InnoDB有表锁还有行锁 `支持MVCC行锁`。而MyIsAM只有表锁。

S-共享锁：又叫读锁，其他事务可以继续加共享锁，但是不能继续加排他锁。
X-排他锁: 又叫写锁，一旦加了写锁之后，其他事务就不能加锁了。

意向锁：
意向共享锁:表达一个事务想要获取一张表中某几行的共享锁。
意向排他锁:表达一个事务想要获取一张表中某几行的排他锁。

## 锁阻塞

1.对于唯一索引或者主键索引不会产生间隙锁。但是非唯一索引的更新操作会产生间隙锁`也就是说，会以目标数据为中心锁住一个范围的数据`，此时如果是插入或者更新的数据也在这个范围内，就会产生阻塞，前面的更新没完事提交commit，后面的更新就无法进行。

0.补充第一条，RR条件下，聚簇索引也会产生间隙锁。就是当where条件没有命中任何记录的时候。

2.如果没有在没有索引的数据上进行更新操作，就会对全表加锁。

>上述两条也就是说，其实在数据库发生更改的时候，为了避免数据更新异常或者读取异常，所以加锁，以满足RR的隔离级别。


3.RC，在RC级别下不会加入间隙锁。为什么RC没有呢？RC表示读取提交的事务。可以避免脏读，但是幻读和可重复读避免不了。及它只会读取其他事务提交的数据，自然不需要间隙锁去控制其他事务的读取操作。

4.聚簇索引 & 非聚簇索引。简单说聚簇索引不但有索引还有表数据，查到后不用回表。
InnoDB 主键使用的是聚簇索引。**所以说通过主键拿到数据是非常廉价的**

## 索引结构
数据库来说，核心动作是查找，不论是增加`在正确的位置插入`，修改，删除，都要找到正确的位置。

对于静态数据，静态查找中折半查找就挺好，但是数据库中的数据是动态变化的，所以要使用动态查找。
数据结构中，动态查找有二叉查找树`也叫二叉排序树`。

但是二叉查找树最坏的情况，元素有序的情况，时间复杂度就是O(n)。
![](https://www.aneasystone.com/usr/uploads/2017/10/1895065164.png)
所以就需要二叉排序树能够自平衡。就是AVL树。

B树是多路平衡树。二叉平衡树，只有两个节点，查询效率低。如果有多个子节点，就能较好的提升查询效率，B树就是拥有多个节点的平衡树。但是为什么mySQL没有使用B树而是B+树呢？这是因为 B 树没有很好的伸缩性，它将多条数据都保存在节点里，如果数据中某个字段太长，一个 page 能容纳的数据量将受到限制，最坏的情况是一个 page 保存一条数据，这个时候 B 树退化成二叉树。

```
B树和B+树的区别
B+树只有在叶子结点才会存储数据。中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素。减少IO消耗。
叶子结点使用链表链接。方便范围查询

```


【重要】[为什么开发人员必须了解数据库锁](https://juejin.im/post/5b6c5be86fb9a04fb30a2bc7)

【重要】[解决死锁之路-常见SQL语句的加锁分析](https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html)

【重要】[解决死锁之路-索引结构](https://www.aneasystone.com/archives/2017/11/solving-dead-locks-two.html)

【重要】[MySQL索引那些事](https://juejin.im/post/5e547f82e51d45270218f5da?utm_source=gold_browser_extension)

[Mysql加锁过程详解7](http://www.cnblogs.com/crazylqy/p/7689447.html)

[解决死锁之路-再见死锁](http://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html)

[间隙锁产生的条件](https://zhuanlan.zhihu.com/p/48269420)

[聚簇索引 & 非聚簇索引](https://juejin.im/post/5cdd701ee51d453a36384939)

[B树 B+树](https://blog.csdn.net/login_sonata/article/details/75268075)

[B+树和红黑树的区别](https://www.jianshu.com/p/86a1fd2d7406)



